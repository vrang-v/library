> 객체지향 패러다임은  지식을 추상화하고  추상화한 지식을 객체 안에 캡슐화함으로써  
> 실세계 문제에 내재된 복잡성을 관리하려고 한다.  
> 객체를 발견하고 창조하는 것은 지식과 행동을 구조화하는 문제다.

2.&nbsp;이상한 나라의 객체
===

## 은유의 함정! 객체지향은 현실 세계의 모방이 아니다.
현실 세계의 객체와는 다르게 프로그래밍 세계에서 객체는 **자율성**을 갖는다.  

**의인화**된 객체는 행동을 스스로 결정할 수 있다.

- 현실 세계에서 '커피' 객체는 사람의 '마신다'는 행동을 통해 상태가 수동적으로 변화한다.


- 프로그래밍 세계에서는 마신다는 행동과 함께 '커피' 객체에게 상태 변화를 요청한다.  
'커피' 객체는 요청을 받아 **스스로** 상태를 변화시킨다.
  
개발자의 임무는 현실 세계의 객체를 모방하는 것이 아니라,  

객체에 **생명**을 불어넣어 객체들끼리 상호작용 하는 **새로운 세상**을 만들어야한다.

## 객체의 상태, 행동 그리고 식별자

> **객체**란?  
> 식별 가능한 개체 또는 사물이다.객체는 자동차처럼 **구체적**인 사물일 수도 있고 시간처럼 **추상적**인 개념일 수도 있다.  
> 객체는 구별 가능한 **식별자**, 특징적인 **행동** 변경 가능한 **상태**를 가진다.  
> 소프트웨어 안어서 객체는 저장된 상태와 실행 가능한 코드를 통해 구현된다.

### - 객체의 상태
> **상태**는 <u>특정 시점에 객체가 가지고 있는 정보의 집합</u>으로 객체의 구조적 특징을 표현한다.  
> 객체의 상태는 객체에 존재하는 **동적인 프로퍼티**와 **정적인 프로퍼티 값**으로 구성된다.  
> 객체의 프로퍼티는 단순한 값과 다른 객체를 참조하는 링크로 구분할 수 있다.
#### 왜 상태가 필요할까?
객체의 현재 행동의 결과는 <u>과거의 행동에 의존적</u>이다.
- 자판기에서 음료를 선택하기 위해서는 이전에 동전을 넣는 행동이 필요하다.

그러나, 행동을 처리하기 위해 이전의 행동을 모두 기억하는 것은 복잡도가 매우 증가한다.
- 자판기에 100원, 500원 동전을 몇 개씩 넣는 행동을 했는지 기억하는 것은 불가능하다

과거의 행동의 결과를 **상태**로 나타내면 현재 행동을 쉽게 예측할 수 있다.
- 투입된 금액이 900원이라는 상태를 이용하면 이전 행동을 기억하지 않아도 된다.

#### 상태와 프로퍼티
객체의 상태는 단순한 값과 객체들의 조합으로 표현할 수 있다.

객체의 상태를 나타내는 특징을 **프로퍼티(property)** 라고 한다. 프로퍼티는 **정적**이다.

프로퍼티를 구체화 하는 **프로퍼티 값(property value)** 은 **동적**이다.

프로퍼티 값은 단순한 값인 **속성(property)** 과 다른 객체를 가리키는 **링크(link)** 로 나눌 수 있다.

### - 객체의 행동
>**행동**은 외부의 요청 또는 수신된 메시지에 응답하기 위해 동작하고 반응하는 활동이다.  
> 행동의 결과로 객체는 **자신의 상태를 변경**하거나 다른 객체에게 **메시지를 전달** 할 수 있다.  
>객체는 행동을 통해 다른 객체와의 협력에 참여하므로 **행동은 외부에 가시적**이어야 한다.

#### 상태와 행동
- 객체의 행동은 현재 상태에 영향을 받는다.
  

- 객체의 행동은 상태를 변화시킨다.

즉, 객체의 행동은 상태를 변화시키고 그 결과는 현재 상태에 의존한다.

    앨리스의 '현재 키 상태'가 40cm 이하라면 문을 통과할 수 있다.

    문을 통과한 뒤에 앨리스의 '위치 상태'는 정원으로 바뀌어야 한다.
#### 협력과 행동
객체는 자신의 상태만을 변화시키지 않는다. 다른 객체에게 부수 효과(side effect)를 끼친다.

    앨리스가 음료를 마시면 앨리스의 상태만이 아니라 '음료의 상태도 바뀐다'.


**이 때! 주의해야 할 것은 모든 객체는 스스로 자신의 상태를 변화시킨다.**  

**다른 객체의 상태에 직접적으로 접근하는 것이 아니라, 다른 객체에게 요청을 보내**

**메시지를 수신한 객체가 스스로 자신의 상태를 바꾸도록 해야 한다.**

    앨리스는 직접 음료의 상태를 변화시킬 수 없다. 음료 객체에게 메시지를 통해 요청을 보내야 한다.

#### 상태의 캡슐화
외부 객체에서의 직접적인 접근을 막고  
객체의 상태를 요청을 통해서만 바꿀 수 있는 것이 결국 상태의 **캡슐화**ㅈ

### - 객체의 식별자
> 식별자는 어떤 객체를 다른 객체와 **구분**하기 위해 사용하는 프로퍼티다.  
> 값은 식별자를 가지지 않기 때문에 **상태**를 이용한 동등성 검사를 통해 두 인스턴스를 비교해야 
> 한다.  
> 객체는 **상태가 변경**될 수 있기 때문에 **식별자**를 이용한 동일성 검사를 통해 두 인스턴스를 
> 비교할 수 있다.

- 객체의 상태는 동적으로 변화하기 때문에 상태를 이용해 동일성을 비교할 수 없다.


- 두 객체의 상태가 같더라도 서로 같은 객체가 아니다.

따라서, 상태에 독립적으로 객체를 유일하게 식별하기 위한 도구가 필요하다.  
이 역할을 수행하는 것이 **식별자**다.

    40cm였던 앨리스가 음료를 먹고 200cm가 됐어도 두 앨리스는 같은 앨리스다.

    두 앨리스가 40cm로 키가 같더라도 같은 앨리스가 아니다.

## 행동이 상태를 결정한다.
객체의 상태를 먼저 결정하고 나중에 행동을 결정하는 경우 아래와 같은 단점이 생긴다.
1. **캡슐화가 저해된다.**
   

    상태에 초점을 맞추게 될 경우 상태가 공용 인터페이스에 노출되기 쉬워진다.
2. **객체를 협력자가 아닌 고립된 섬으로 만든다.**


    행동이 아닌 상태에 초점이 맞춰진 객체는 협력에 적합하지 못하게 된다.
3. **객체의 재사용성이 떨어진다.**


    다양한 협력에 참여하지 못하는 객체는 자연스레 재사용성이 떨어진다.  
    객체의 행동이란 결국 협력에서 각 객체가 완수해야 할 책임을 의미한다.

객체를 거대한 문제를 풀기 위해 서로 다르고 작은 책임을 갖는 것으로 바라보아야

응집도 높고 재사용성이 높은 일급객체를 만들 수 있다.
>객체의 적합성을 결정하는 것은 상태가 아니라 행동이다!
